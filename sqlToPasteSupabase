create extension if not exists "pgcrypto";

-- Story version history (idempotent)
begin;

create table if not exists public.story_versions (
  id uuid primary key default gen_random_uuid(),
  story_id uuid not null references public.stories (id) on delete cascade,
  user_id uuid not null references auth.users (id) on delete cascade,
  title text not null default '',
  content text not null default '',
  reason text not null default '',
  tags jsonb not null default '[]'::jsonb,
  start_date timestamptz,
  end_date timestamptz,
  dates_precision text,
  photos jsonb not null default '[]'::jsonb,
  saved_at timestamptz not null default timezone('utc', now()),
  created_at timestamptz not null default timezone('utc', now())
);

create index if not exists story_versions_story_id_saved_at_idx
  on public.story_versions (story_id, saved_at desc);

alter table public.story_versions enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'story_versions'
      and policyname = 'Story versions are viewable by owner'
  ) then
    create policy "Story versions are viewable by owner"
      on public.story_versions
      for select
      using (auth.uid() = user_id);
  end if;
end
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'story_versions'
      and policyname = 'Story versions are insertable by owner'
  ) then
    create policy "Story versions are insertable by owner"
      on public.story_versions
      for insert
      with check (auth.uid() = user_id);
  end if;
end
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'story_versions'
      and policyname = 'Story versions are updatable by owner'
  ) then
    create policy "Story versions are updatable by owner"
      on public.story_versions
      for update
      using (auth.uid() = user_id)
      with check (auth.uid() = user_id);
  end if;
end
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'story_versions'
      and policyname = 'Story versions are deletable by owner'
  ) then
    create policy "Story versions are deletable by owner"
      on public.story_versions
      for delete
      using (auth.uid() = user_id);
  end if;
end
$$;

commit;

-- Public access policies for published stories and related data
begin;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'stories'
      and policyname = 'Published stories are viewable publicly'
  ) then
    create policy "Published stories are viewable publicly"
      on public.stories
      for select using (
        status = 'published'
        or published_at is not null
      );
  end if;
end
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'tags'
      and policyname = 'Published tags are viewable publicly'
  ) then
    create policy "Published tags are viewable publicly"
      on public.tags
      for select using (
        exists (
          select 1 from public.story_tags st
          join public.stories s on s.id = st.story_id
          where st.tag_id = tags.id
            and (s.status = 'published' or s.published_at is not null)
        )
      );
  end if;
end
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'story_tags'
      and policyname = 'Published story tags are viewable publicly'
  ) then
    create policy "Published story tags are viewable publicly"
      on public.story_tags
      for select using (
        exists (
          select 1 from public.stories s
          where s.id = story_tags.story_id
            and (s.status = 'published' or s.published_at is not null)
        )
      );
  end if;
end
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'story_photos'
      and policyname = 'Published story photos are viewable publicly'
  ) then
    create policy "Published story photos are viewable publicly"
      on public.story_photos
      for select using (
        exists (
          select 1 from public.stories s
          where s.id = story_photos.story_id
            and (s.status = 'published' or s.published_at is not null)
        )
      );
  end if;
end
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'people'
      and policyname = 'Published people are viewable publicly'
  ) then
    create policy "Published people are viewable publicly"
      on public.people
      for select using (
        exists (
          select 1 from public.story_people sp
          join public.stories s on s.id = sp.story_id
          where sp.person_id = people.id
            and (s.status = 'published' or s.published_at is not null)
        )
      );
  end if;
end
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'story_people'
      and policyname = 'Published story people are viewable publicly'
  ) then
    create policy "Published story people are viewable publicly"
      on public.story_people
      for select using (
        exists (
          select 1 from public.stories s
          where s.id = story_people.story_id
            and (s.status = 'published' or s.published_at is not null)
        )
      );
  end if;
end
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'user_settings'
      and policyname = 'Published author settings are viewable publicly'
  ) then
    create policy "Published author settings are viewable publicly"
      on public.user_settings
      for select using (
        exists (
          select 1 from public.stories s
          where s.user_id = user_settings.user_id
            and (s.status = 'published' or s.published_at is not null)
        )
      );
  end if;
end
$$;

commit;

-- Ensure metadata columns exist for story versions
begin;

alter table public.story_versions
  add column if not exists tags jsonb not null default '[]'::jsonb,
  add column if not exists start_date timestamptz,
  add column if not exists end_date timestamptz,
  add column if not exists dates_precision text,
  add column if not exists photos jsonb not null default '[]'::jsonb;

update public.story_versions
set tags = '[]'::jsonb
where tags is null;

update public.story_versions
set photos = '[]'::jsonb
where photos is null;

commit;

-- Ensure stories table stores publication timestamps
begin;

alter table public.stories
  add column if not exists published_at timestamptz;

update public.stories
set published_at = coalesce(published_at, updated_at)
where status = 'published' and published_at is null;

commit;

-- Subscriber magic links & tracking
begin;

alter table public.subscribers
  add column if not exists access_token text default encode(gen_random_bytes(24), 'hex'),
  add column if not exists access_token_created_at timestamptz default timezone('utc', now()),
  add column if not exists access_token_last_sent_at timestamptz,
  add column if not exists last_access_at timestamptz,
  add column if not exists last_access_ip inet,
  add column if not exists last_access_user_agent text,
  add column if not exists last_access_source text;

update public.subscribers
set
  access_token = coalesce(access_token, encode(gen_random_bytes(24), 'hex')),
  access_token_created_at = coalesce(access_token_created_at, timezone('utc', now()))
where access_token is null or access_token = '';

create unique index if not exists subscribers_access_token_key
  on public.subscribers (access_token)
  where access_token is not null and access_token <> '';

commit;

-- Subscriber access audit
begin;

create table if not exists public.subscriber_access_events (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.users(id) on delete cascade,
  subscriber_id uuid not null references public.subscribers(id) on delete cascade,
  story_id uuid references public.stories(id) on delete cascade,
  access_token text,
  event_type text not null check (event_type in ('link_sent', 'link_opened', 'invite_opened', 'access_granted')),
  metadata jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default timezone('utc', now())
);

create index if not exists subscriber_access_events_subscriber_idx
  on public.subscriber_access_events (subscriber_id, created_at desc);

alter table public.subscriber_access_events enable row level security;

alter table public.subscriber_access_events
  drop constraint if exists subscriber_access_events_event_type_check;

alter table public.subscriber_access_events
  add constraint subscriber_access_events_event_type_check
    check (event_type in ('link_sent', 'link_opened', 'invite_opened', 'access_granted'));

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'subscriber_access_events'
      and policyname = 'Owners manage subscriber access events'
  ) then
    create policy "Owners manage subscriber access events"
      on public.subscriber_access_events
      for all
      using (auth.uid() = user_id)
      with check (auth.uid() = user_id);
  end if;
end
$$;

commit;

-- RPC para validar accesos de suscriptores desde la aplicación pública
begin;

create or replace function public.register_subscriber_access(
  p_author_id uuid,
  p_subscriber_id uuid,
  p_token text,
  p_story_id uuid default null,
  p_source text default null,
  p_event_type text default 'access_granted',
  p_request_ip inet default null,
  p_user_agent text default null
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_subscriber public.subscribers%rowtype;
  v_now timestamptz := timezone('utc', now());
  v_event_type text := lower(coalesce(nullif(p_event_type, ''), 'access_granted'));
  v_source text := nullif(trim(coalesce(p_source, '')), '');
  v_user_agent text := nullif(trim(coalesce(p_user_agent, '')), '');
begin
  select *
    into v_subscriber
    from public.subscribers
   where id = p_subscriber_id
     and user_id = p_author_id;

  if not found then
    return jsonb_build_object(
      'status', 'not_found',
      'message', 'No encontramos este suscriptor.'
    );
  end if;

  if v_subscriber.status = 'unsubscribed' then
    return jsonb_build_object(
      'status', 'forbidden',
      'message', 'Este suscriptor canceló su acceso.'
    );
  end if;

  if v_subscriber.access_token is null
     or trim(v_subscriber.access_token) = ''
     or trim(v_subscriber.access_token) <> trim(coalesce(p_token, '')) then
    return jsonb_build_object(
      'status', 'forbidden',
      'message', 'El enlace ya caducó o no es válido.'
    );
  end if;

  update public.subscribers
     set status = case when status <> 'confirmed' then 'confirmed' else status end,
         last_access_at = v_now,
         last_access_ip = coalesce(p_request_ip, last_access_ip),
         last_access_user_agent = coalesce(substring(v_user_agent from 1 for 512), last_access_user_agent),
         last_access_source = coalesce(v_source, last_access_source)
   where id = v_subscriber.id;

  insert into public.subscriber_access_events (
    user_id,
    subscriber_id,
    story_id,
    access_token,
    event_type,
    metadata
  ) values (
    p_author_id,
    v_subscriber.id,
    p_story_id,
    v_subscriber.access_token,
    case
      when v_event_type = 'link_sent' then 'link_sent'
      when v_event_type = 'link_opened' then 'link_opened'
      when v_event_type = 'invite_opened' then 'invite_opened'
      else 'access_granted'
    end,
    jsonb_build_object(
      'source', coalesce(v_source, null),
      'ip', case when p_request_ip is null then null else p_request_ip::text end,
      'userAgent', v_user_agent
    )
  );

  return jsonb_build_object(
    'status', 'ok',
    'data', jsonb_build_object(
      'grantedAt', v_now,
      'token', v_subscriber.access_token,
      'source', coalesce(v_source, v_subscriber.last_access_source),
      'subscriber', jsonb_build_object(
        'id', v_subscriber.id,
        'name', v_subscriber.name,
        'email', v_subscriber.email,
        'status', 'confirmed'
      )
    )
  );
end;
$$;

grant execute on function public.register_subscriber_access(
  uuid,
  uuid,
  text,
  uuid,
  text,
  text,
  inet,
  text
) to anon, authenticated;

commit;

-- Subscriber feedback: story comments
begin;

create table if not exists public.story_comments (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.users(id) on delete cascade,
  story_id uuid not null references public.stories(id) on delete cascade,
  subscriber_id uuid references public.subscribers(id) on delete set null,
  author_name text not null default '',
  author_email text,
  content text not null,
  source text,
  metadata jsonb not null default '{}'::jsonb,
  status text not null default 'visible' check (status in ('visible', 'hidden', 'flagged')),
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz
);

create index if not exists story_comments_story_idx
  on public.story_comments (story_id, created_at desc);

create index if not exists story_comments_subscriber_idx
  on public.story_comments (subscriber_id, created_at desc);

alter table public.story_comments enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'story_comments'
      and policyname = 'Authors manage own story comments'
  ) then
    create policy "Authors manage own story comments"
      on public.story_comments
      for all
      using (auth.uid() = user_id)
      with check (auth.uid() = user_id);
  end if;
end
$$;

do $$
begin
  if not exists (
    select 1 from pg_trigger
    where tgname = 'update_story_comments_updated_at'
      and tgrelid = 'public.story_comments'::regclass
  ) then
    create trigger update_story_comments_updated_at
      before update on public.story_comments
      for each row execute procedure update_updated_at_column();
  end if;
end
$$;

commit;

-- Subscriber feedback: story reactions
begin;

create table if not exists public.story_reactions (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.users(id) on delete cascade,
  story_id uuid not null references public.stories(id) on delete cascade,
  subscriber_id uuid references public.subscribers(id) on delete set null,
  reaction_type text not null default 'heart' check (reaction_type in ('heart')),
  source text,
  metadata jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default timezone('utc', now())
);

create unique index if not exists story_reactions_unique_idx
  on public.story_reactions (story_id, subscriber_id, reaction_type)
  where subscriber_id is not null;

create index if not exists story_reactions_story_idx
  on public.story_reactions (story_id, created_at desc);

create index if not exists story_reactions_subscriber_idx
  on public.story_reactions (subscriber_id, created_at desc);

alter table public.story_reactions enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public'
      and tablename = 'story_reactions'
      and policyname = 'Authors manage own story reactions'
  ) then
    create policy "Authors manage own story reactions"
      on public.story_reactions
      for all
      using (auth.uid() = user_id)
      with check (auth.uid() = user_id);
  end if;
end
$$;

commit;

-- Subscriber engagement summary view
begin;

create or replace view public.subscriber_engagement_summary as
select
  s.id as subscriber_id,
  s.user_id,
  coalesce(count(distinct sr.id), 0) as total_reactions,
  coalesce(count(distinct sc.id), 0) as total_comments,
  max(sr.created_at) as last_reaction_at,
  max(sc.created_at) as last_comment_at
from public.subscribers s
left join public.story_reactions sr on sr.subscriber_id = s.id
left join public.story_comments sc on sc.subscriber_id = s.id
group by s.id, s.user_id;

commit;
